from sqlalchemy import Column, String, DateTime, Text, Integer, Enum, UniqueConstraint
from sqlalchemy.sql import func
from . import Base
from enum import Enum as PyEnum
import uuid
"""
    I should change name of this model and its classses to message if I get time later 
    for now I will keep it as content 
"""
class ContentType(PyEnum):
    TEXT = 'text'
    VOICE = 'voice'

class Source(PyEnum):
    EMAIL = 'email'
    TELEGRAM = 'telegram'

class Content(Base):
    """Main content table for all message types (text, voice, image, etc.).
    
    Required columns for message model:
    - source: message source (email, telegram, etc.)
    - date: message timestamp
    - category: message classification (via Classification table)
    - extracted entities: entities from content (via Entity table)
    - original text: message content
    """
    
    __tablename__ = 'content'
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))  # UUID generated by database
    source_id = Column(String(255), nullable=False)  # Original platform ID (Gmail ID, Telegram ID, etc.)
    content_type = Column(Enum(ContentType), nullable=False)  # 'text', 'voice' 
    content_data = Column(Text, nullable=False)         
    content_html = Column(Text, nullable=True)         # HTML formatted content , this is for email messages 
    source = Column(Enum(Source), nullable=False)         # 'email', 'telegram'
    timestamp = Column(DateTime, nullable=False)        # this is the timestamp of the message 
    created_at = Column(DateTime, default=func.now())   
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())
    
    # Add unique constraint to prevent duplicate messages from same source
    __table_args__ = (
        UniqueConstraint('source_id', 'source', name='uq_source_id_source'),
    )
    
    def __repr__(self):
        return f"<Content(id='{self.id}', source_id='{self.source_id}', type='{self.content_type}', source='{self.source}')>"
    
    def to_dict(self):
        """Convert to dictionary for API responses."""
        return {
            'id': self.id,
            'source_id': self.source_id,
            'content_type': self.content_type.value if self.content_type else None,
            'content_data': self.content_data,
            'content_html': self.content_html,
            'source': self.source.value if self.source else None,
            'timestamp': self.timestamp.isoformat() if self.timestamp else None,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None
        } 